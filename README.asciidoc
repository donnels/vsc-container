= VSCode Container Project
:toc: right
:sectnums:
:sectnumlevels: 5

A production-ready containerized VS Code server environment with SSL certificate support and reverse proxy architecture for secure remote development.

image::images/config-overview.png[Project Structure, 800, 600]

== Service Discovery and Networking

The system uses CoreDNS for internal service discovery within the `vsagcrd.org` domain:

* *proxy.vsagcrd.org* (172.20.0.11) - Nginx reverse proxy with SSL termination
* *vscode.vsagcrd.org* (172.20.0.12) - VS Code Server application
* *coredns.vsagcrd.org* (172.20.0.10) - Internal DNS resolver
* *certbot.vsagcrd.org* (172.20.0.13) - Certificate management (run-once)

This architecture provides:

* Consistent internal hostname resolution
* Simplified container communication
* Production-ready network segregation
* Automatic service discovery

=== External Access

All external access flows through the proxy at `your-domain.vsagcrd.org` (standard HTTPS port 443):

----
Intranet → your-domain.vsagcrd.org:443 → proxy.vsagcrd.org → vscode.vsagcrd.org:8443
----

== Architectural Decisions

=== Proxy-First Architecture

This project exclusively uses a reverse proxy architecture for the following reasons:

**DNS Simplicity**::
- No need to modify local DNS or hosts files
- Works seamlessly with public domains
- Avoids port-specific access patterns that confuse users

**Production Readiness**::
- Standard HTTPS on port 443 (not custom ports like 8443)
- Proper SSL termination at the edge
- HTTP to HTTPS automatic redirection

**Security Benefits**::
- SSL/TLS handled by dedicated proxy layer
- Security headers automatically applied
- No direct container exposure to public internet

**Operational Simplicity**::
- Single entry point for all traffic
- Centralized certificate management
- Standard web server patterns that ops teams understand

**Future Extensibility**::
- Load balancing capabilities built-in
- Multiple backend support ready
- Monitoring and logging integration points

=== DNS Architecture: CoreDNS with Dynamic Local Detection

The project uses CoreDNS for internal service discovery with intelligent local DNS detection:

**Local Network Awareness**::
- Automatically detects and uses local DNS servers (Fritz Box when home, mobile DNS when traveling)
- No hardcoded DNS servers (avoiding Google DNS, respecting privacy)
- Seamless portability across different network environments

**Internal Service Discovery**::
- Simple `/etc/hosts` format for internal services (.vsagcrd.org domain)
- Automatic forward and reverse DNS generation
- Easy maintenance with single hosts file

**Network Isolation Benefits**::
- Internal container communication via DNS names, not IP addresses
- Clear separation between internal services and external DNS
- Reduced configuration complexity for users

== Quick Start

. Clone this repository:
+
[source,bash]
----
git clone https://github.com/donnels/vsc-container.git
cd vsc-container/docker
----

. Generate Let's Encrypt certificates:
+
[source,bash]
----
cp docker-certbot/.env.template docker-certbot/.env
# Edit docker-certbot/.env with your Cloudflare credentials and domain configuration
docker-compose --profile tools run cert-generator
----

. Configure proxy environment:
+
[source,bash]
----
cp docker-proxy/.env.template docker-proxy/.env
# Edit docker-proxy/.env with your certificate name (should match certbot PROXY_CERT_NAME)
----

. Configure VS Code service:
+
[source,bash]
----
cp docker-vsc/.env.template docker-vsc/.env
# Edit docker-vsc/.env with your certificate name (should match certbot VSCODE_CERT_NAME)
----

. Start the development environment:
+
[source,bash]
----
docker-compose --profile dev up -d
----

. Access VS Code at: `https://your-subdomain.vsagcrd.org` (standard HTTPS port 443)

. Start the complete environment:
+
[source,bash]
----
docker-compose up
----

. Access VS Code at `https://vsagcrd.org` (standard HTTPS port 443)

== Architecture Overview

The system uses a three-tier architecture designed for production deployment:

image::images/proxy-deployment-sequence.png[Production Architecture Flow, 800, 600]

=== Service Components

**CoreDNS Service** (`docker-coredns/`)::
- Internal DNS resolution for `.vsagcrd.org` domain
- Service discovery for container-to-container communication
- Static IP assignment and hostname resolution
- Forwards external queries to public DNS servers

**Nginx Reverse Proxy** (`docker-proxy/`)::
- SSL termination with Let's Encrypt certificates for `vsagcrd.org`
- HTTP to HTTPS redirection  
- Security headers and modern TLS configuration
- WebSocket support for VS Code real-time features
- Standard ports: 80 (HTTP redirect) and 443 (HTTPS)

**VS Code Service** (`docker-vsc/`)::
- Code-server accessible as `vscode.vsagcrd.org` internally
- Uses dedicated Let's Encrypt certificate (separate from proxy)
- Pre-installed development extensions (PlantUML, AsciiDoctor)
- Internal network access only (security isolation)
- Development tools: Java, Graphviz, standard utilities

**Certificate Generator** (`docker-certbot/`)::
- Generates separate Let's Encrypt certificates for proxy and VS Code services
- Cloudflare DNS-01 challenge for automated domain validation
- Configurable certificate names and domain sets for each service
- Automated certificate renewal capabilities
- On-demand execution via Docker Compose profiles
- Accessible as `certbot.vsagcrd.org` internally

=== Network Architecture

[source,text]
----
Internet → Nginx Proxy (443/80) → CoreDNS (172.20.0.10) → VS Code Container (vscode.vsagcrd.org:8443)
                ↓                           ↓
          Let's Encrypt Certs      Internal DNS Resolution
              (Volume)              (.vsagcrd.org domain)
----

**Service Discovery**::
- CoreDNS provides internal DNS resolution for `.vsagcrd.org` domain
- Each service has a static IP and hostname (e.g., `vscode.vsagcrd.org`)
- Container-to-container communication uses domain names, not IP addresses
- External DNS queries forwarded to public DNS servers (8.8.8.8, 1.1.1.1)

**Security Boundaries**::
- Public internet only reaches the proxy service
- All internal services isolated on private network (172.20.0.0/16)
- Certificate volume shared read-only with proxy
- DNS resolution controlled by internal CoreDNS server

=== Directory Structure

[source,text]
----
docker/
├── docker-compose.yaml          # Complete orchestration
├── docker-coredns/               # Internal DNS server
│   ├── Corefile                 # CoreDNS configuration
│   └── hosts                    # Internal domain host mappings
├── docker-proxy/                # Nginx reverse proxy
│   ├── Dockerfile
│   ├── nginx.conf               # Production SSL config (legacy)
│   ├── nginx.conf.template      # Templated SSL config  
│   └── .env.template
├── docker-vsc/                  # VS Code server
│   ├── Dockerfile
│   ├── generate_certs.sh        # Extension installation script
│   ├── extensions.json          # Pre-installed extensions
│   └── .env.template
└── docker-certbot/              # Certificate management
    ├── Dockerfile
    ├── entrypoint.sh            # Let's Encrypt automation
    └── .env.template
images/                           # Technical diagrams → PNG
docs/                            # Generated documentation
includes/                        # Modular documentation content
.github/workflows/               # Documentation automation
----

== SSL Certificate Management

The system exclusively uses Let's Encrypt certificates for production-grade SSL:

image::images/cert-generator-sequence.png[Certificate Generation Process, 800, 600]

=== Certificate Generation Process

==== Prerequisites

. Register your domain with a registrar
. Configure domain DNS through Cloudflare
. Create Cloudflare API token with DNS edit permissions: https://dash.cloudflare.com/profile/api-tokens
. Obtain Cloudflare Zone ID for your domain

==== Certificate Generation Steps

. Configure certificate generator:
+
[source,bash]
----
cd docker
cp docker-certbot/.env.template docker-certbot/.env
----

. Edit `docker-certbot/.env` with your credentials:
+
[source,properties]
----
DOMAIN=vsagcrd.org
CLOUDFLARE_API_TOKEN=your_api_token_here
CLOUDFLARE_ZONE_ID=your_zone_id_here

# Proxy certificate (for external access)
PROXY_DOMAINS=vsagcrd.org,www.vsagcrd.org
PROXY_CERT_NAME=proxy

# VS Code certificate (for internal access)
VSCODE_DOMAINS=vscode.vsagcrd.org,code.vsagcrd.org
VSCODE_CERT_NAME=vscode

# Generate both certificates (set to false to skip)
GENERATE_PROXY_CERT=true
GENERATE_VSCODE_CERT=true
----

. Generate certificates:
+
[source,bash]
----
docker-compose --profile tools run cert-generator
----

. Certificates are automatically available to the proxy via Docker volume

==== Certificate Renewal

Certificates can be renewed by re-running the certificate generator:

[source,bash]
----
docker-compose --profile tools run cert-generator
docker-compose restart proxy
----

For automated renewal, set up a cron job or systemd timer to run the generation command.

== Development Environment

=== Included Development Tools

**Pre-installed Extensions**::
- PlantUML: Technical diagram creation with Java runtime and Graphviz
- AsciiDoctor: Technical documentation authoring and preview

**Development Stack**::
- VS Code Server with full extension support
- Git for version control
- Node.js development tools
- Java 17 runtime for PlantUML
- Standard Unix utilities (curl, wget, openssl)

**Security Features**::
- Password-protected access
- HTTPS-only communication
- Internal network isolation
- Non-root container execution

=== Container Configuration

VS Code service configuration via environment variables:

[source,properties]
----
# VS Code certificate name (must match certbot VSCODE_CERT_NAME)
VSCODE_CERT_NAME=vscode

# VS Code authentication settings
CODE_SERVER_PASSWORD_HASH=CHANGE_THIS_HASH
CODE_SERVER_AUTH_MESSAGE=Virtual Space Research
----

Proxy service configuration via environment variables:

[source,properties]
----
# Proxy certificate name (must match certbot PROXY_CERT_NAME)
PROXY_CERT_NAME=proxy
----

== Deployment

=== Single Deployment Model

The system uses one standardized deployment approach:

. **Certificate Generation**: Use Let's Encrypt with DNS validation
. **Proxy Deployment**: Nginx handles SSL termination and routing
. **Standard Ports**: HTTP (80) redirects to HTTPS (443)
. **Domain-Based**: Requires proper domain configuration

=== Deployment Steps

. Configure DNS to point your domain to the deployment server
. Generate certificates using the certificate generator
. Start all services with docker-compose
. Access via standard HTTPS URL

=== Production Considerations

**Domain Requirements**::
- Must have a registered domain name
- Domain must be configured in Cloudflare DNS
- DNS must resolve to the deployment server's public IP

**Server Requirements**::
- Docker and Docker Compose installed
- Ports 80 and 443 accessible from internet
- Sufficient resources for development workloads

**Security Considerations**::
- Automatic security headers via Nginx
- Modern TLS configuration (TLS 1.2+)
- HTTP Strict Transport Security (HSTS)
- No direct container exposure to internet

== Operations and Maintenance

=== Monitoring and Logs

Access logs for troubleshooting:

[source,bash]
----
# All services
docker-compose logs

# Specific services
docker-compose logs proxy
docker-compose logs code-server
docker-compose --profile tools logs cert-generator
----

=== Certificate Management

Monitor certificate expiration:

[source,bash]
----
# Check certificate details
openssl x509 -in <(docker-compose exec proxy cat /etc/nginx/certs/proxy/fullchain.pem) -text -noout
----

Automate renewal with cron:

[source,bash]
----
# Add to crontab for monthly renewal
0 0 1 * * cd /path/to/project/docker && docker-compose --profile tools run cert-generator && docker-compose restart proxy
----

=== Troubleshooting

**Common Issues**::

- **Certificate Generation Fails**: Verify Cloudflare API token permissions and DNS configuration
- **Proxy Won't Start**: Check certificate files exist in volume
- **Access Denied**: Verify domain DNS points to correct server
- **WebSocket Issues**: Ensure proxy configuration includes WebSocket support

**Diagnostic Commands**::

[source,bash]
----
# Test certificate generation
docker-compose --profile tools run cert-generator

# Verify proxy configuration
docker-compose exec proxy nginx -t

# Check internal connectivity
docker-compose exec proxy curl -k https://vscode.vsagcrd.org:8443
----

== Extension and Customization

=== Adding Custom Extensions

Modify `docker-vsc/extensions.json` and rebuild:

[source,json]
----
{
  "recommendations": [
    "jebbs.plantuml",
    "asciidoctor.asciidoctor-vscode",
    "your.custom.extension"
  ]
}
----

=== Custom Nginx Configuration

Edit `docker-proxy/nginx.conf` for:

- Custom security headers
- Additional upstream services
- Rate limiting
- Custom routing rules

=== Documentation Extensions

- Add `.asciidoc` files anywhere for automatic building
- Create `.plantuml` files for automatic diagram generation
- Extend GitHub Actions workflow for additional build steps

== Contributing

1. Fork the repository
2. Create feature branch: `git checkout -b feature/enhancement`
3. Test changes with full deployment
4. Ensure documentation builds correctly
5. Submit pull request with architectural justification

All documentation and diagrams are automatically built and updated via GitHub Actions.

[appendix]
include::includes/Documentation-System.adoc[]

[appendix]
include::includes/Include-Glossary.adoc[]

---

*This project provides a production-ready, secure development environment following modern containerization and security best practices.*

include::includes/Include-Glossary.adoc[]


