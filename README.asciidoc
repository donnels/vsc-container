= VSCode Container Project
:toc: right
:sectnums:
:sectnumlevels: 5

A production-ready containerized VS Code server environment with HAProxy reverse proxy architecture for secure remote development.

image::images/config-overview.png[Reverse Proxy Architecture, 800, 600]

== Reverse Proxy Architecture

The system uses HAProxy as a reverse proxy with SSL termination:

* *proxy.vsagcrd.org* (172.20.0.11:8443) - HAProxy reverse proxy with self-signed certificate
* *code-dev.vsagcrd.org* (172.20.0.12:8443) - VS Code Server with Let's Encrypt certificate
* *coredns.vsagcrd.org* (172.20.0.10:53) - Internal DNS resolver
* *certbot.vsagcrd.org* (172.20.0.13) - Certificate management (run-once)

This architecture provides:

* **SSL termination** with self-signed certificate for external access
* **Let's Encrypt certificates** for backend VSCode security
* **Self-signed certificate** on forward proxy (no Let's Encrypt rate limit concerns)
* **HTTPS tunneling** preserves original SSL certificates through the proxy
* **WebSocket compatibility** without SSL termination complexity
* **Enterprise-grade HAProxy** for robust proxy functionality

=== External Access Flow

All external access flows through the HAProxy forward proxy:

----
Meta Quest 3 → Fritz.Box → HAProxy Forward Proxy:8443 → VSCode:8443
    ↑                           ↑                           ↑
Self-signed cert           HTTPS tunnel              Let's Encrypt cert
(accept once)            (transparent)              (end-to-end secure)
----

== Architectural Decisions

=== Forward Proxy vs Reverse Proxy

This project uses a **forward proxy architecture** for the following reasons:

**SSL Simplicity**::
- **Self-signed certificate** on proxy eliminates Let's Encrypt rate limit concerns
- **No certificate sharing** between containers - each service manages its own
- **No SSL termination complexity** - proxy tunnels encrypted traffic transparently
- **Preserved end-to-end encryption** with real Let's Encrypt certificates

**WebSocket Compatibility**::
- **Direct WebSocket tunneling** without SSL re-encryption complications
- **No proxy SSL verification** issues that cause WebSocket connection failures
- **Transparent protocol handling** for all HTTPS traffic

**Development Simplicity**::
- **Single certificate warning** on initial proxy connection (user accepts once)
- **No Fritz.Box DNS changes** required - uses standard proxy configuration
- **Standard browser proxy settings** - works with any HTTPS-capable client

== Quick Start - Reverse Proxy Deployment

=== Step 1: Generate Let's Encrypt Certificates (VSCode only)

----
# Configure Cloudflare credentials
cp docker/.env.template docker/.env
# Edit docker/.env with your Cloudflare credentials and domain configuration
# Edit .env file with your Cloudflare API token and domains

# Generate VSCode certificate only
cd docker
podman-compose up cert-generator
----

=== Step 2: Start Reverse Proxy and VSCode

----
# Start all services (proxy with self-signed cert + VSCode with LE cert)
cd docker
podman-compose up -d
----

=== Step 3: Access VSCode Directly

1. **Accept Self-Signed Certificate**: Navigate to `https://steamdeck.fritz.box:8443` and accept the certificate warning (one-time only)

2. **Access VSCode**: Direct HTTPS access to `https://steamdeck.fritz.box:8443` - no proxy configuration needed

3. **LCARS Interface**: Status interface at `http://steamdeck.fritz.box:8080`

=== Architecture Benefits

**No Let's Encrypt Rate Limits**::
- Forward proxy uses self-signed certificate (unlimited)
- Only VSCode service uses Let's Encrypt certificate
- Significant reduction in certificate requests

**Simplified SSL Management**::
- No certificate sharing between containers
- No complex nginx SSL upstream configuration
- No WebSocket SSL proxy complications

**End-to-End Security**::
- Browser → Proxy: HTTPS with self-signed certificate
- Proxy → VSCode: HTTPS tunnel with Let's Encrypt certificate
- Full encryption maintained throughout the connection

== Service Discovery and Networking

The system uses CoreDNS for internal service discovery within the `vsagcrd.org` domain:

* *forward-proxy.vsagcrd.org* (172.20.0.11:8443) - HAProxy forward proxy with self-signed certificate
* *code-dev.vsagcrd.org* (172.20.0.12:8443) - VS Code Server with Let's Encrypt certificate
* *coredns.vsagcrd.org* (172.20.0.10:53) - Internal DNS resolver
* *certbot.vsagcrd.org* (172.20.0.13) - Certificate management (run-once)

**LCARS Status Interface**: Available at `http://localhost:8080` for proxy status and system information.
- Security headers automatically applied
- No direct container exposure to public internet

**Operational Simplicity**::
- Single entry point for all traffic
- Centralized certificate management
- Standard web server patterns that ops teams understand

**Future Extensibility**::
- Load balancing capabilities built-in
- Multiple backend support ready
- Monitoring and logging integration points

=== DNS Architecture: CoreDNS with Dynamic Local Detection

The project uses CoreDNS for internal service discovery with intelligent local DNS detection:

**Local Network Awareness**::
- Automatically detects and uses local DNS servers (Fritz Box when home, mobile DNS when traveling)
- No hardcoded DNS servers (avoiding Google DNS, respecting privacy)
- Seamless portability across different network environments

**Internal Service Discovery**::
- Simple `/etc/hosts` format for internal services (.vsagcrd.org domain)
- Automatic forward and reverse DNS generation
- Easy maintenance with single hosts file

**Network Isolation Benefits**::
- Internal container communication via DNS names, not IP addresses
- Clear separation between internal services and external DNS
- Reduced configuration complexity for users

== Quick Start

. Clone this repository:
+
[source,bash]
----
git clone https://github.com/donnels/vsc-container.git
cd vsc-container/docker
----

. Generate Let's Encrypt certificates:
+
[source,bash]
----
# Edit docker/.env with your Cloudflare credentials and domain configuration
docker-compose run deflector
----

. Configure proxy environment:
+
[source,bash]
----
cp docker-proxy/.env.template docker-proxy/.env
# Edit docker-proxy/.env with your certificate name (should match certbot PROXY_CERT_NAME)
----

. Configure VS Code service:
+
[source,bash]
----
cp docker-vsc/.env.template docker-vsc/.env
# Edit docker-vsc/.env with your certificate name (should match certbot VSCODE_CERT_NAME)
----

. Start the development environment:
+
[source,bash]
----
docker-compose up -d
----

. Access VS Code at: `https://your-subdomain.vsagcrd.org` (standard HTTPS port 443)

. Start the complete environment:
+
[source,bash]
----
docker-compose up
----

. Access VS Code at `https://vsagcrd.org` (standard HTTPS port 443)

== Architecture Overview

The system uses a three-tier architecture designed for production deployment:

image::images/proxy-deployment-sequence.png[Production Architecture Flow, 800, 600]

=== Service Components

**CoreDNS Service** (`docker-locator-matrix/`)::
- Internal DNS resolution for `.warp.vsagcrd.org` domain
- Service discovery for container-to-container communication
- Static IP assignment and hostname resolution
- Forwards external queries to public DNS servers

**Squid Forward Proxy** (`docker-transporter/`)::
- Forward proxy with HTTPS tunneling for `.vsagcrd.org` domains
- Squid-based proxy for mobile network traversal
- Standard ports: 3128 (main)

**VS Code Service** (`docker-engineering-console/`)::
- Code-server accessible as `engineering-console.warp.vsagcrd.org` internally
- Uses dedicated Let's Encrypt certificate (separate from proxy)
- Pre-installed development extensions (PlantUML, AsciiDoctor)
- Internal network access only (security isolation)
- Development tools: Java, Graphviz, standard utilities

**Certificate Generator** (`docker-deflector/`)::
- Generates separate Let's Encrypt certificates for all services
- Cloudflare DNS-01 challenge for automated domain validation
- Configurable certificate names and domain sets for each service
- Automated certificate renewal capabilities
- Accessible as `deflector.warp.vsagcrd.org` internally

=== Network Architecture

[source,text]
----
Internet → Nginx Proxy (443/80) → CoreDNS (172.20.0.10) → VS Code Container (vscode.vsagcrd.org:8443)
                ↓                           ↓
          Let's Encrypt Certs      Internal DNS Resolution
              (Volume)              (.vsagcrd.org domain)
----

**Service Discovery**::
- CoreDNS provides internal DNS resolution for `.vsagcrd.org` domain
- Each service has a static IP and hostname (e.g., `vscode.vsagcrd.org`)
- Container-to-container communication uses domain names, not IP addresses
- External DNS queries forwarded to public DNS servers (8.8.8.8, 1.1.1.1)

**Security Boundaries**::
- Public internet only reaches the proxy service
- All internal services isolated on private network (172.20.0.0/16)
- Certificate volume shared read-only with proxy
- DNS resolution controlled by internal CoreDNS server

=== Directory Structure

[source,text]
----
docker/
├── docker-compose.yaml          # Complete orchestration
├── .env                         # Centralized configuration
├── docker-locator-matrix/       # Internal DNS server (CoreDNS)
│   ├── Corefile                 # CoreDNS configuration
│   └── hosts.template           # Internal domain host mappings
├── docker-engineering-console/  # VS Code server
│   ├── Dockerfile
│   ├── generate_certs.sh        # Extension installation script
│   ├── extensions.json          # Pre-installed extensions
│   └── nginx.conf
├── docker-deflector/            # Certificate management (Let's Encrypt)
│   ├── Dockerfile
│   ├── entrypoint.sh            # Let's Encrypt automation
├── docker-transporter/          # Squid forward proxy (main)
│   ├── Dockerfile
│   ├── squid6.conf.template
│   └── squid-start.sh
├── docker-shuttlebay/           # Landing page (Nginx)
│   ├── Dockerfile
│   ├── nginx.conf
│   └── html/
├── docker-console/              # LCARS interface (Nginx)
│   ├── Dockerfile
│   ├── nginx.conf.template
│   └── lcars/
└── docker-optical-data-network/ # MQTT message bus
    ├── Dockerfile
    ├── mosquitto.conf.template
    └── entrypoint.sh
    └── .env.template
images/                           # Technical diagrams → PNG
docs/                            # Generated documentation
includes/                        # Modular documentation content
.github/workflows/               # Documentation automation
----

== SSL Certificate Management

The system exclusively uses Let's Encrypt certificates for production-grade SSL:

image::images/cert-generator-sequence.png[Certificate Generation Process, 800, 600]

=== Certificate Generation Process

==== Prerequisites

. Register your domain with a registrar
. Configure domain DNS through Cloudflare
. Create Cloudflare API token with DNS edit permissions: https://dash.cloudflare.com/profile/api-tokens
. Obtain Cloudflare Zone ID for your domain

==== Certificate Generation Steps

. Configure certificate generator:
+
[source,bash]
----
cd docker
cp docker-certbot/.env.template docker-certbot/.env
----

. Edit `docker-certbot/.env` with your credentials:
+
[source,properties]
----
DOMAIN=vsagcrd.org
CLOUDFLARE_API_TOKEN=your_api_token_here
CLOUDFLARE_ZONE_ID=your_zone_id_here

# Proxy certificate (for external access)
PROXY_DOMAINS=vsagcrd.org,www.vsagcrd.org
PROXY_CERT_NAME=proxy

# VS Code certificate (for internal access)
VSCODE_DOMAINS=vscode.vsagcrd.org,code.vsagcrd.org
VSCODE_CERT_NAME=vscode

# Generate both certificates (set to false to skip)
GENERATE_PROXY_CERT=true
GENERATE_VSCODE_CERT=true
----

. Generate certificates:
+
[source,bash]
----
docker-compose run cert-generator
----

. Certificates are automatically available to the proxy via Docker volume

==== Certificate Renewal

Certificates can be renewed by re-running the certificate generator:

[source,bash]
----
docker-compose run cert-generator
docker-compose restart proxy
----

For automated renewal, set up a cron job or systemd timer to run the generation command.

== Development Environment

=== Included Development Tools

**Pre-installed Extensions**::
- PlantUML: Technical diagram creation with Java runtime and Graphviz
- AsciiDoctor: Technical documentation authoring and preview

**Development Stack**::
- VS Code Server with full extension support
- Git for version control
- Node.js development tools
- Java 17 runtime for PlantUML
- Standard Unix utilities (curl, wget, openssl)

**Security Features**::
- Password-protected access
- HTTPS-only communication
- Internal network isolation
- Non-root container execution

=== Container Configuration

VS Code service configuration via environment variables:

[source,properties]
----
# VS Code certificate name (must match certbot VSCODE_CERT_NAME)
VSCODE_CERT_NAME=vscode

# VS Code authentication settings
CODE_SERVER_PASSWORD_HASH=CHANGE_THIS_HASH
CODE_SERVER_AUTH_MESSAGE=Virtual Space Research
----

Proxy service configuration via environment variables:

[source,properties]
----
# Proxy certificate name (must match certbot PROXY_CERT_NAME)
PROXY_CERT_NAME=proxy
----

== Deployment

=== Single Deployment Model

The system uses one standardized deployment approach:

. **Certificate Generation**: Use Let's Encrypt with DNS validation
. **Proxy Deployment**: Nginx handles SSL termination and routing
. **Standard Ports**: HTTP (80) redirects to HTTPS (443)
. **Domain-Based**: Requires proper domain configuration

=== Deployment Steps

. Configure DNS to point your domain to the deployment server
. Generate certificates using the certificate generator
. Start all services with docker-compose
. Access via standard HTTPS URL

=== Production Considerations

**Domain Requirements**::
- Must have a registered domain name
- Domain must be configured in Cloudflare DNS
- DNS must resolve to the deployment server's public IP

**Server Requirements**::
- Docker and Docker Compose installed
- Ports 80 and 443 accessible from internet
- Sufficient resources for development workloads

**Security Considerations**::
- Automatic security headers via Nginx
- Modern TLS configuration (TLS 1.2+)
- HTTP Strict Transport Security (HSTS)
- No direct container exposure to internet

== Operations and Maintenance

=== DNS Resolution Testing

The warp bubble implements a hybrid DNS strategy (<<ARCID-012>>) where Docker handles internal service discovery and CoreDNS handles external forwarding. Test the complete DNS resolution:

[source,bash]
----
# Run comprehensive DNS test suite
./test-dns-resolution.sh
----

The test script validates:
- Internal service discovery via Docker aliases
- External DNS forwarding through CoreDNS
- Cross-container communication
- Star Trek themed hostname resolution
- MQTT connectivity and package manager functionality

=== Monitoring and Logs

Access logs for troubleshooting:

[source,bash]
----
# All services
docker-compose logs

# Specific services
docker-compose logs proxy
docker-compose logs code-server
docker-compose logs cert-generator
----

=== Certificate Management

Monitor certificate expiration:

[source,bash]
----
# Check certificate details
openssl x509 -in <(docker-compose exec proxy cat /etc/nginx/certs/proxy/fullchain.pem) -text -noout
----

Automate renewal with cron:

[source,bash]
----
# Add to crontab for monthly renewal
0 0 1 * * cd /path/to/project/docker && docker-compose run cert-generator && docker-compose restart proxy
----

=== Troubleshooting

**Common Issues**::

- **Certificate Generation Fails**: Verify Cloudflare API token permissions and DNS configuration
- **Proxy Won't Start**: Check certificate files exist in volume
- **Access Denied**: Verify domain DNS points to correct server
- **WebSocket Issues**: Ensure proxy configuration includes WebSocket support

**Diagnostic Commands**::

[source,bash]
----
# Test certificate generation
docker-compose run cert-generator

# Verify proxy configuration
docker-compose exec proxy nginx -t

# Check internal connectivity
docker-compose exec proxy curl -k https://vscode.vsagcrd.org:8443
----

== Extension and Customization

=== Adding Custom Extensions

Modify `docker-vsc/extensions.json` and rebuild:

[source,json]
----
{
  "recommendations": [
    "jebbs.plantuml",
    "asciidoctor.asciidoctor-vscode",
    "your.custom.extension"
  ]
}
----

=== Custom Nginx Configuration

Edit `docker-proxy/nginx.conf` for:

- Custom security headers
- Additional upstream services
- Rate limiting
- Custom routing rules

=== Documentation Extensions

- Add `.asciidoc` files anywhere for automatic building
- Create `.plantuml` files for automatic diagram generation
- Extend GitHub Actions workflow for additional build steps

== Contributing

1. Fork the repository
2. Create feature branch: `git checkout -b feature/enhancement`
3. Test changes with full deployment
4. Ensure documentation builds correctly
5. Submit pull request with architectural justification

All documentation and diagrams are automatically built and updated via GitHub Actions.

[appendix]
include::includes/Documentation-System.adoc[]

[appendix]
include::includes/Include-Glossary.adoc[]

---

*This project provides a production-ready, secure development environment following modern containerization and security best practices.*

include::includes/Include-Glossary.adoc[]


