
services:
  # CoreDNS server for complete bidirectional DNS resolution
  locator-matrix:
    build:
      context: ./docker-locator-matrix
      dockerfile: Dockerfile
    environment:
      - WARP_DOMAIN=${WARP_DOMAIN}
      - BASE_DOMAIN=${BASE_DOMAIN}
      - WARPBUBBLE_SERVICES=${WARPBUBBLE_SERVICES}
      # Pass all IP variables for hosts file generation
      - WARPBUBBLE_IP_LOCATOR_MATRIX=${WARPBUBBLE_IP_LOCATOR_MATRIX}
      - WARPBUBBLE_IP_DIAGNOSTIC_ARRAY=${WARPBUBBLE_IP_DIAGNOSTIC_ARRAY}
      - WARPBUBBLE_IP_ENGINEERING_CONSOLE=${WARPBUBBLE_IP_ENGINEERING_CONSOLE}
      - WARPBUBBLE_IP_DEFLECTOR=${WARPBUBBLE_IP_DEFLECTOR}
      - WARPBUBBLE_IP_SHUTTLEBAY=${WARPBUBBLE_IP_SHUTTLEBAY}
      - WARPBUBBLE_IP_TRANSPORTER=${WARPBUBBLE_IP_TRANSPORTER}
      - WARPBUBBLE_IP_TRANSPORTER_TEST=${WARPBUBBLE_IP_TRANSPORTER_TEST}
      - WARPBUBBLE_IP_CONSOLE=${WARPBUBBLE_IP_CONSOLE}
      - WARPBUBBLE_IP_OPTICAL_DATA_NETWORK=${WARPBUBBLE_IP_OPTICAL_DATA_NETWORK}
    ports:
      - "${WARPBUBBLE_PORT_LOCATOR_MATRIX:-53}:53/udp"  # DNS
      - "${WARPBUBBLE_PORT_LOCATOR_MATRIX_TCP:-53}:53/tcp"  # DNS over TCP
      - "9153:9153"  # CoreDNS metrics
    volumes:
      - locator-matrix-data:/data
    restart: unless-stopped
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_LOCATOR_MATRIX}
        aliases:
          - locator-matrix.${WARP_DOMAIN}
          - dns.${WARP_DOMAIN}

  # DNS Diagnostic Array - Star Trek themed testing container
  diagnostic-array:
    build:
      context: ./docker-diagnostic-array
      dockerfile: Dockerfile
    profiles:
      - tools
      - diagnostics
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        aliases:
          - diagnostic-array.${WARP_DOMAIN}
    command: ["sleep", "infinity"]  # Keep container running for manual testing

  engineering-console:
    build:
      context: ./docker-engineering-console
      dockerfile: Dockerfile
    environment:
      - CERT_HOSTNAMES=${CERT_HOSTNAMES:-code-dev.${BASE_DOMAIN:-vsagcrd.org} localhost 127.0.0.1}
      - VSCODE_CERT_NAME=${VSCODE_CERT_NAME:-vscode}
      - PASSWORD=${PASSWORD:-vscode}
      - CODE_SERVER_PASSWORD_HASH=${CODE_SERVER_PASSWORD_HASH}
      - CODE_SERVER_AUTH_MESSAGE=${CODE_SERVER_AUTH_MESSAGE}
      - VIRTUAL_HOST=${VIRTUAL_HOST}
      - NGINX_LOG_PATH=${NGINX_LOG_PATH}
    volumes:
      - ../:/workspace
      - ../data:/data
      - engineering-console-config:/home/coder/.config/code-server
      - engineering-console-data:/home/coder/.local/share/code-server
      - engineering-console-code:/home/coder/code
      - cert-output:/etc/letsencrypt:ro
    command: ["/usr/bin/code-server", "/home/coder/code", "--bind-addr", "0.0.0.0:8443", "--auth", "password", "--cert", "/etc/letsencrypt/live/${VSCODE_CERT_NAME:-vscode}/fullchain.pem", "--cert-key", "/etc/letsencrypt/live/${VSCODE_CERT_NAME:-vscode}/privkey.pem"]
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_ENGINEERING_CONSOLE}
        aliases:
          - engineering-console.${WARP_DOMAIN}
          - vscode.${WARP_DOMAIN}

  deflector:
    build:
      context: ./docker-deflector
      dockerfile: Dockerfile
    environment:
      - DOMAIN=${DOMAIN}
      - CLOUDFLARE_API_TOKEN=${CLOUDFLARE_API_TOKEN}
      - WEB_DOMAINS=${WEB_DOMAINS}
      - WEB_CERT_NAME=${WEB_CERT_NAME}
      - VSCODE_DOMAINS=${VSCODE_DOMAINS}
      - VSCODE_CERT_NAME=${VSCODE_CERT_NAME}
      - CONSOLE_DOMAINS=${CONSOLE_DOMAINS}
      - CONSOLE_CERT_NAME=${CONSOLE_CERT_NAME}
      - GENERATE_WEB_CERT=${GENERATE_WEB_CERT}
      - GENERATE_VSCODE_CERT=${GENERATE_VSCODE_CERT}
      - GENERATE_CONSOLE_CERT=${GENERATE_CONSOLE_CERT}
      - GENERATE_PROXY_CERT=${GENERATE_PROXY_CERT}
    volumes:
      - cert-output:/etc/letsencrypt
    profiles:
      - tools
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_DEFLECTOR}
        aliases:
          - deflector.${WARP_DOMAIN}

  # Nginx web server - serves landing page and HTTPS menu
  shuttlebay:
    build:
      context: ./docker-shuttlebay
      dockerfile: Dockerfile
    ports:
      - "${WARPBUBBLE_PORT_SHUTTLEBAY}:80"   # Landing page (exposed)
    volumes:
      - cert-output:/etc/letsencrypt:ro
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_SHUTTLEBAY}
        aliases:
          - shuttlebay.${WARP_DOMAIN}

  # Squid 6 forward proxy for HTTPS tunneling
  transporter:
    build:
      context: ./docker-transporter
      dockerfile: Dockerfile
    ports:
      - "${WARPBUBBLE_PORT_TRANSPORTER}:3128"  # Forward proxy port (squid default is 3128)
    volumes:
      - transporter-cache:/var/spool/squid
      - transporter-logs:/var/log/squid
    depends_on:
      - shuttlebay
      - engineering-console
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_TRANSPORTER}
        aliases:
          - transporter.${WARP_DOMAIN}

  # TEST: Ubuntu default entrypoint with hybrid config
  transporter-test:
    build:
      context: ./docker-transporter-test
      dockerfile: Dockerfile
    ports:
      - "${WARPBUBBLE_PORT_TRANSPORTER_TEST}:3128"  # Test on different port
    volumes:
      - transporter-test-cache:/var/spool/squid
      - transporter-test-logs:/var/log/squid
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_TRANSPORTER_TEST}
        aliases:
          - transporter-test.${WARP_DOMAIN}

  # LCARS Console - Pure nginx web server with Star Trek themed interface
  console:
    build:
      context: ./docker-console
      dockerfile: Dockerfile
    ports:
      - "${WARPBUBBLE_PORT_CONSOLE}:80"  # LCARS Console HTTP
    environment:
      - WARP_DOMAIN=${WARP_DOMAIN}
    volumes:
      - cert-output:/etc/letsencrypt:ro
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_CONSOLE}
        aliases:
          - console.${WARP_DOMAIN}

  # MQTT Message Bus - Optical Data Network for secure system communication
  optical-data-network:
    build:
      context: ./docker-optical-data-network
      dockerfile: Dockerfile
    ports:
      - "8883:8883"  # MQTT over TLS
    volumes:
      - optical-data-network-config:/mosquitto/config
      - optical-data-network-data:/mosquitto/data
      - optical-data-network-logs:/mosquitto/log
      - cert-output:/etc/letsencrypt:ro
    restart: unless-stopped
    dns:
      - ${WARPBUBBLE_IP_LOCATOR_MATRIX}
    networks:
      warpbubble:
        ipv4_address: ${WARPBUBBLE_IP_OPTICAL_DATA_NETWORK}
        aliases:
          - optical-data-network.${WARP_DOMAIN}
          - odn.${WARP_DOMAIN}

volumes:
  locator-matrix-data:
  engineering-console-config:
  engineering-console-data:
  engineering-console-code:
  cert-output:
  transporter-cache:
  transporter-logs:
  transporter-test-cache:
  transporter-test-logs:
  optical-data-network-config:
  optical-data-network-data:
  optical-data-network-logs:

networks:
  warpbubble:
    driver: bridge
    ipam:
      config:
        - subnet: ${WARPBUBBLE_NETWORK_SUBNET}
